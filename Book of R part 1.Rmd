---
title: "Book of R Part 1"
output: html_document
date: '2022-06-05'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Exercie 2.1
```{r}
#(a)
(6*(2.3)+42)/3^(4.2-3.62)
#(b) 
#Answer is i
#(c)
x<-c(25.2, 15,16.44,15.3,18.6)
sqrt(mean(x)/2)
#suggested answer
sqrt(x=0.5*((25.2+15+16.44+15.3+18.6)/5))

#(d)
y<-log(x=0.3)
#(e)
exp(y)
#(f)
#The answer will be -4.23546322e-09
-0.00000000423546322
```


Exercise 2.2
```{r}
#(a)
a <- 3^2*4^(1/8)
#(b)
a <- a/2.33
a
#(c)
b <- -8.2e-13
#(d)
a*b
```

Exercise 2.3
```{r}
#(a)
a<-seq(from=5, to=-11, by=-0.3)
a
#(b)
sort(x=a,decreasing=FALSE)
#(c)
b<-rep(c(-1,3,-5,7,-9), times=2, each=10)
sort(x=b,decreasing=TRUE)
#(d)
vout<-c(seq(from=6,to=12), 
        rep(x=5.3, times=3),
        -3,
        seq(from=102, to=length(b), length.out=9)
        )
#(e)
length(vout)
```

Exercise 2.4
```{r}
#(a)
v1<-seq(from=3, to=6, length.out=5)
v2<-rep(c(2,-5.1,-33),times=2)
v3<-7/42+2
(vout<-c(v1,v2,v3))
#answer
foo <- c(seq(from=3,to=6,length.out=5),rep(c(2,-5.1,-33),times=2),7/42+2)
foo

#(b)
newvec<-vout[c(1,length(vout))]
#(c)
omitvec<-vout[-c(1,length(vout))]
#(d)
reconstrv<-c(newvec[1],omitvec,newvec[2]) #listed in orig order
reconstrv<-c(newvec,omitvec) #listed newvec followed by omitvec
#(e)
ascend_v<-sort(reconstrv, decreasing=FALSE)
#(f)
ascend_v[length(ascend_v):1]
sort(reconstrv, decreasing=TRUE)
#(g)
a<-rep(x=omitvec[3],times=3)
b<-rep(x=omitvec[6],times=4)
c<-omitvec[length(omitvec)]
finv<-c(a,b,c)
#alternative way 
owrascend_v<-c(rep(x=omitvec[3],times=3),
               rep(x=omitvec[6],times=4),
               omitvec[length(omitvec)])
#answer
baz <- foo[-c(1,length(x=foo))]
baz[c(rep(x=3,times=3),rep(x=6,times=4),length(x=baz))]

#(h)
ascend_v[c(1,5:7,length(ascend_v))]<-99:95
```

Exercise 2.5
```{r}
#(a)
vec_a<-c(2,0.5,1,2,0.5,1,2,0.5,1)
vec_a[1:length(vec_a)] <- c(1,1,1)
vec_a
#suggested solution (use this)
c(2,0.5,1,2,0.5,1,2,0.5,1)/c(2,0.5,1)

#(b)
fer_v<-c(45,77,20,19,101,120,212)
cel<-(fer_v-32)*5/9

#(c)
vec1<-c(2,4,6)
vec2<-c(1,2)
vec3<-rep(x=vec2,each=3)
vecout<-vec1*vec3  #vec1 length is 3 vec3 length is 6
#suggested solution (use this)
foo <- rep(x=c(2,4,6),times=2)*rep(x=c(1,2),each=3)
foo

#(d)
vecout[2:5]<-rep(x=c(-0.1,-100),times=2)
#solution
foo[2:5] <- c(-0.1,-100) #lengths different but works
foo

```

Chapter 3.2
```{r}
A <- matrix(c(0.3,4.5,55.3,91,0.1,105.5,-4.2,8.2,27.9),
             nrow=3, ncol=3)
A

A[-1,3:2]
A[c(2,3), 3:2]

A[-1,-2]
A[c(2,3),c(1,3)]

diag(x=A)<-0
A
```

Exercise 3.1
```{r}
#(a)
mymatrix<-matrix(c(4.3, 3.1, 8.2, 8.2, 3.2, 0.9, 1.6, 6.5), 
                 nrow = 4,
                 ncol = 2,
                 byrow = TRUE)

#(b)
dim(mymatrix)
newmatrix<-mymatrix[-1,]  #removed the first row
dim(newmatrix)

#(c)
mymatrix
mymatrix [,2]<-sort(mymatrix[,2],decreasing=FALSE) #decreasing false is default
c_matrix<-mymatrix

#(d) Use the suggested solution instead
newc_matrix<-c_matrix[-4,] #delete fourth row 
newc_vec<-newc_matrix[,-1] #delete the first col, additionally
#suggested solution 
newc_vec<-c_matrix[-4,-1]

#(e)
twobytwo_matrix<-c_matrix[3:4,]
#(f)
c_matrix  #inspect matrix
twobytwo_matrix  #inspect matrix
c_matrix[c(4,1),c(2,1)]<-(-1/2*diag(twobytwo_matrix))
c_matrix
```


Exercise 3.2
```{r}
#(a)
a<-matrix(c(1,2,7,2,4,6), nrow=3, ncol= 2) # one way to create matrix
b<-cbind(c(10,30,50),c(20,40,60)) #second way to create a matrix
dim(a)  #check the cols in "a" matching the rows in "b" to prevent error
dim(b)  #for matrix by matrix product checking is important
2/7 * (a-b)
##solution (same outcome as mine)
2/7*(cbind(c(1,2,7),c(2,4,6))-cbind(c(10,30,50),c(20,40,60)))

#(b)
A<-matrix(c(1,2,7),nrow=3,ncol=1)
B<-matrix(c(3,4,8),nrow=3, ncol=1)
#solution (same outcome as mine)
AA <- matrix(data=c(1,2,7))
BB <- matrix(data=c(3,4,8))

##i -cannot compute - got this one wrong made correction
A*B # n=1 is not equal to p=3; non-conformable error

##ii -can compute - got this one wrong, made correction
dim(t(A)) #m=1,n=3 
dim(B) #p=3,q=1 ; n is equal to p
t(A)%*%B
##solution
t(AA)%*%BB #not used "*" bc this is matrices multiplication

##iii -can compute 
dim(A)
dim(t(A)) #A times transposed A can certainly be multiplied bc n=p. the resulting matrix is m x q=4
A #inspect matrix
t(A) #inspect matrix; n=p=1 so I can multiply
A_products<-A%*%t(A) #because two matrices are not identical in dimension
#Examine n=p?
dim(t(B)) #dim is 1,3 (n=3)
dim(A_products) #dim is 3,3 (p=3); resulting matrix should be m xq = 3
t(B)%*%A_products #matrix dims different so cannot use "*" to multiply
##solution (same thing; one line version)
t(BB)%*%(AA%*%t(AA))

##iv -cannot compute (the order matters- see iii; n is not equal to p here)
dim(A_products) #3 by 3 matrix; n=3
dim(t(B)) #1 by 3 matrix; p=1
A_products%*%t(B) #n is not equal to p

##v -cannot compute
### first term
dim(B) #3 x 1 
dim(t(B)) #1 x3
B%*%t(B) #transposed matrix should multiply fine; result=3x3 matrix
### second term
A_products #this is 3 x3 matrix
###third term
100*diag(x=3) #3 x3 matrix
###put together and inverse of everything
solve(B%*%t(B)+A_products-100*diag(x=3)) #all three terms are 3 x3
## solution (same thing pretty much)
solve(BB%*%t(BB)+AA%*%t(AA)-100*diag(3))

#(c) - couldn't figure out
#Solution: used solve() for inverse -matrix A is a square matrix
A <- rbind(c(2,0,0,0),c(0,3,0,0),c(0,0,5,0),c(0,0,0,-1))
solve(A)%*%A-diag(4) #inverse times the original A equal to 1. 
```


```{r}

#(c)
A <- rbind(c(2,0,0,0),c(0,3,0,0),c(0,0,5,0),c(0,0,0,-1))
solve(A)%*%A-diag(4)

```

